2024.12.2
1.创建工程，开始“拾光”服务端的开发。
2.根据类图，初步完成类的构建。

2024.12.3
1.熟悉了头文件包含问题，全局变量声明定义问题。
2.开始线程池的搭建...
3.构建了一个Task类，通过函数指针使其存储了一个任意方法函数，及其可变参数。

2024.12.4
1.参数可变的函数的传递与储存：
    一.
        1)void(*callback)(int count, ...);  //函数指针
        2)void A(void(*callback)(int count, ...), int count, ...);  //传递
        3)利用<stdarg.h>的函数获取参数;
        缺点：没有类型及边界检查，不安全，不建议使用;
             要传递的函数写法固定为 类型 函数名(int count, ...)。
    二.
        1)template<typename... Args>
          void(*callback)(Args...);  //错误写法
        2)template<typename... Args>
          void A(void(*callback)(Args...), Args... args);
        3)利用模板参数包和函数参数包实现;
        缺点：不能声明模板函数指针(成员)变量，只能在模板函数中作为参数传递，故不能储存一个可变函数。
    三.
        1)void(*callback)(void*a,void*b,void*c);
        2)void A(void(*callback)(void*a,void*b,void*c),
                 void*a=nullptr,void*b=nullptr,void*c=nullptr);
        3）利用void*实现;
        缺点：参数最大数量固定;
             要传递的函数写法固定为 类型 函数名(void*a,void*b,void*c)。
2024.12.6
1.解决线程池的一些bug。

2024.12.7
1.完善线程池的搭建。
2.写加锁，如果只加一边相当于没加，猜测：锁不住正在读写的线程。
  总结：加锁+加锁=加锁；加锁+不加锁=不加锁。
  例如：写加锁+写加锁=两者加锁状态；
       写加锁+读不加锁=两者不加锁状态，对写没影响，对读有影响,如：连续读几个变量，数据更改不同步。
3.问题：线程池析构函数，不能加锁(会相互阻塞)导致有极小的概率会造成同时join和detach异常终止程序，情况如下：
  线程池正在销毁，突然加了个任务，子线程被唤醒又检测到需要自杀，该线程就有极低概率同时被读写，然后会都执行detach和join，异常终止。
  虽然概率小，但是建议销毁线程池前，等任务执行完，线程自动销毁完。
  
2024.12.8
1.完善上述问题。
2.shared_mutex读写锁(C++17)在条件变量condition_variable(C++11)中不支持，如：wait(unique<mutex>&);
  故：读写锁在这里优势也不大，采用互斥锁。
3.建议多线程环境，读写都加锁。
4.线程池完成测试。

2024.12.9
1.开始实现服务器的网络编程。

2024.12.10
1.epoll，卡在了IO多路复用。

2024.12.11
1.epoll阶段基本结束。

2024.12.13
1.发现将主线程的变量通过指针传递到子线程的隐患，改写添加任务函数。
2.框架搭建完毕，根据客户端请求添加任务即可。
             
2024.12.14
1.开始数据库阶段的编程。
2.再次调整任务函数，最终以指针传递堆对象来实现。
3.回调函数不能是成员函数。
             
2024.12.15
1.又要大改，使用bind()函数，函数对象，泛型编程技术实现真正的可变参数函数。
2.模板函数声明和定义不能分开写。
3.完成大改。
             
             
             
             

             

             
             
             
             
             
             
